# การอธิบายคุณสมบัติ Polymorphism (พอลีมอร์ฟิซึม) ใน OOP

# Polymorphism หรือ พอลีมอร์ฟิซึม คือคุณสมบัติที่อนุญาตให้ฟังก์ชันหรือเมธอดหนึ่งๆ
# ทำงานได้กับประเภทต่างๆ ของอ็อบเจกต์ ซึ่งหมายความว่า เราสามารถใช้ชื่อฟังก์ชันเดียว
# เพื่อทำงานกับอ็อบเจกต์ที่แตกต่างกันได้ โดยไม่ต้องเปลี่ยนชื่อฟังก์ชันในแต่ละคลาส
#
# การใช้ Polymorphism ช่วยให้โค้ดมีความยืดหยุ่นสูงและสามารถทำงานกับอ็อบเจกต์หลายประเภทได้
# โดยไม่ต้องสร้างฟังก์ชันใหม่สำหรับแต่ละประเภท
#
# **ข้อดีของ Polymorphism**:
# 1. ทำให้โค้ดดูสะอาดและยืดหยุ่น
# 2. ช่วยให้สามารถใช้ฟังก์ชันเดียวกันในการทำงานกับอ็อบเจกต์หลายๆ ประเภท
# 3. ช่วยให้การดูแลรักษาโค้ดง่ายขึ้นและไม่ต้องแก้ไขฟังก์ชันในหลายๆ ที่

# ตัวอย่าง:

class Robot:
    """
    คลาสแม่ (Parent Class) ที่เป็นพื้นฐานของหุ่นยนต์
    คลาสนี้มีฟังก์ชัน `move()` ที่จะทำงานได้กับทุกประเภทของหุ่นยนต์
    """

    def move(self):
        print("Robot is moving forward.")

class WalkingRobot(Robot):
    """
    คลาสลูกที่สืบทอดมาจาก Robot และปรับปรุงฟังก์ชัน `move()` ให้เหมาะสมกับหุ่นยนต์เดิน
    """

    def move(self):
        print("Walking Robot is walking forward.")

class FlyingRobot(Robot):
    """
    คลาสลูกที่สืบทอดมาจาก Robot และปรับปรุงฟังก์ชัน `move()` ให้เหมาะสมกับหุ่นยนต์บิน
    """

    def move(self):
        print("Flying Robot is flying forward.")

# ฟังก์ชันที่ใช้ Polymorphism
def make_move(robot):
    """
    ฟังก์ชันนี้รับอ็อบเจกต์ประเภทใดๆ ที่เป็นหุ่นยนต์ และเรียกใช้ฟังก์ชัน `move()`
    โดยไม่ต้องกังวลเกี่ยวกับประเภทของหุ่นยนต์นั้นๆ
    """
    robot.move()

# สร้างอ็อบเจกต์จากคลาสต่างๆ
robot = Robot()
walking_robot = WalkingRobot()
flying_robot = FlyingRobot()

# เรียกใช้ฟังก์ชัน `make_move` โดยไม่ต้องรู้ว่าหุ่นยนต์แต่ละตัวเป็นประเภทใด
make_move(robot)         # Output: Robot is moving forward.
make_move(walking_robot) # Output: Walking Robot is walking forward.
make_move(flying_robot)  # Output: Flying Robot is flying forward.

# คำอธิบาย:
# - ในตัวอย่างนี้, เรามีฟังก์ชัน `make_move()` ซึ่งรับอ็อบเจกต์จากคลาส `Robot` หรือคลาสที่สืบทอดจาก `Robot`
# - ฟังก์ชัน `make_move()` สามารถเรียกใช้ฟังก์ชัน `move()` จากอ็อบเจกต์ทุกประเภทได้
#   โดยไม่ต้องรู้ว่าอ็อบเจกต์นั้นเป็นหุ่นยนต์ประเภทใด
# - นี่คือการใช้ **Polymorphism** ซึ่งทำให้ฟังก์ชันเดียวสามารถทำงานกับอ็อบเจกต์หลายประเภทได้

# ขยายความ:

# 1. **Polymorphism** คือการที่ฟังก์ชันเดียวสามารถทำงานกับอ็อบเจกต์ที่แตกต่างกันได้
#    - ในตัวอย่างนี้, ฟังก์ชัน `make_move()` ใช้ชื่อเดียวกันในการเรียกใช้ฟังก์ชัน `move()` จากอ็อบเจกต์ประเภทต่างๆ
#    - ไม่ว่าจะเป็นหุ่นยนต์ประเภท `Robot`, `WalkingRobot`, หรือ `FlyingRobot`, ฟังก์ชัน `move()` จะแสดงพฤติกรรมที่เหมาะสม
#      ตามประเภทของหุ่นยนต์ที่ส่งเข้าไป
#    - **Polymorphism** ช่วยให้เราไม่ต้องเขียนฟังก์ชันแยกต่างหากสำหรับแต่ละประเภทหุ่นยนต์ แต่ใช้ฟังก์ชันเดียว
#      ในการทำงานกับทุกประเภท

# 2. **Dynamic Dispatch**:
#    - **Dynamic Dispatch** คือกระบวนการที่การเรียกใช้ฟังก์ชันจะถูกตัดสินใจในขณะรันไทม์ ขึ้นอยู่กับประเภทของอ็อบเจกต์ที่ถูกส่งเข้าไป
#    - ในที่นี้, เมื่อเราส่งอ็อบเจกต์ประเภท `WalkingRobot` ฟังก์ชัน `move()` ใน `WalkingRobot` จะถูกเรียกใช้
#      และเมื่อเราส่งอ็อบเจกต์ประเภท `FlyingRobot` ฟังก์ชัน `move()` ใน `FlyingRobot` จะถูกเรียกใช้
#    - ฟังก์ชันที่เรียกใช้จะไม่ถูกตัดสินใจในช่วงคอมไพล์ แต่ในระหว่างการรัน

# 3. **Method Overriding**:
#    - **Method Overriding** คือการที่ฟังก์ชันในคลาสลูก (เช่น `WalkingRobot`, `FlyingRobot`) ทับ (Override) ฟังก์ชันในคลาสแม่
#      เพื่อเปลี่ยนพฤติกรรมของฟังก์ชันให้เหมาะสมกับคลาสลูก
#    - ในตัวอย่างนี้, คลาส `WalkingRobot` และ `FlyingRobot` ได้ทำการ Overriding ฟังก์ชัน `move()` 
#      เพื่อให้แสดงผลที่แตกต่างกันตามประเภทของหุ่นยนต์

# 4. **ข้อดีของ Polymorphism**:
#    - **ยืดหยุ่น**: ฟังก์ชันเดียวสามารถทำงานกับหลายประเภทอ็อบเจกต์ได้
#    - **สะอาดและมีประสิทธิภาพ**: ลดจำนวนฟังก์ชันที่ต้องสร้างใหม่
#    - **ง่ายต่อการบำรุงรักษา**: เมื่อมีการเพิ่มคลาสใหม่ที่สืบทอดจากคลาสแม่ (เช่น `WalkingRobot`, `FlyingRobot`)
#      ฟังก์ชัน `make_move()` ยังสามารถทำงานได้กับคลาสใหม่โดยไม่ต้องแก้ไข
#    - **บำรุงรักษาง่าย**: เพราะไม่ต้องเขียนโค้ดซ้ำซ้อนและสามารถจัดการกับอ็อบเจกต์หลากหลายได้ในที่เดียว
